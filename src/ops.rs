//! Implements builtin Rust operators for `Expression`s
//!
//! Implements operators to all `Expression`s
//! whose underlying type supports them.
//! The types here are simply expressions that represent
//! the respective computation of the operator.
//!
//! **Note:** Most types in this module are generated by macros,
//! and so will have very skim documentation, if any.

use std::ops::*;

macro_rules! impl_lazy_binop(
    ($wrapper:ident -> $op_ty:ident::$op_fn:ident) => {
        #[derive(Debug, Clone)]
        pub struct $wrapper<
            A: $op_ty<B, Output=O>,
            B,
            O,
            EA: $crate::Expression<A>,
            EB: $crate::Expression<B>,
        >(
            EA, EB,
            ::std::marker::PhantomData<A>,
            ::std::marker::PhantomData<B>,
            ::std::marker::PhantomData<O>,
        );

        impl<A, B, O, EA, EB> $crate::Expression<O> for $wrapper<A, B, O, EA, EB>
            where
                A: $op_ty<B, Output=O>,
                EA: $crate::Expression<A>,
                EB: $crate::Expression<B>,
        {
            fn evaluate(self) -> O {
                let a = self.0.evaluate();
                let b = self.1.evaluate();
                a.$op_fn(b)
            }
        }

        impl<A, O, EA, EB> $op_ty<EB> for $crate::Lazy<A, EA>
            where
                A: $op_ty<A, Output=O>,
                EA: $crate::Expression<A>,
                EB: $crate::Expression<A>,
        {
            type Output = $wrapper<A, A, O, EA, EB>;

            fn $op_fn(self, other: EB) -> Self::Output {
                $wrapper(
                    self.0, other,
                    ::std::marker::PhantomData,
                    ::std::marker::PhantomData,
                    ::std::marker::PhantomData,
                )
            }
        }
    };
);

impl_lazy_binop!(LazyAdd -> Add::add);
impl_lazy_binop!(LazySub -> Sub::sub);
impl_lazy_binop!(LazyMul -> Mul::mul);
impl_lazy_binop!(LazyDiv -> Div::div);
impl_lazy_binop!(LazyBitAnd -> BitAnd::bitand);
impl_lazy_binop!(LazyBitOr -> BitOr::bitor);
impl_lazy_binop!(LazyBitXor -> BitXor::bitxor);

#[cfg(test)]
mod tests {
    use super::super::{lazy, Expression};

    #[test]
    fn add() {
        let a = lazy(1);
        let b = lazy(2);
        assert_eq!((a + b).evaluate(), 3);
    }

    #[test]
    fn sub() {
        let a = lazy(1);
        let b = lazy(2);
        assert_eq!((a - b).evaluate(), -1);
    }

    #[test]
    fn mul() {
        let a = lazy(1);
        let b = lazy(2);
        assert_eq!((a * b).evaluate(), 2);
    }

    #[test]
    fn div() {
        let a = lazy(15);
        let b = lazy(5);
        assert_eq!((a / b).evaluate(), 3);
    }

    #[test]
    fn bitand() {
        let a = lazy(1);
        let b = lazy(2);
        assert_eq!((a & b).evaluate(), 0);
    }

    #[test]
    fn bitor() {
        let a = lazy(1);
        let b = lazy(2);
        assert_eq!((a | b).evaluate(), 3);
    }

    #[test]
    fn bitxor() {
        let a = lazy(2);
        let b = lazy(3);
        assert_eq!((a ^ b).evaluate(), 1);
    }
}
